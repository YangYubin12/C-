# C++
> ✅ 프로세스, 스레드, 네임 맹글링, 페이징, 세그멘테이션, 커널 힙 알고리즘, vertor, 덱 이론 정리

## <br> 1. 프로세스
- C++ 프로그램은 소스 코드 작성 후 컴파일을 통해 기계어로 변환되며, 이를 실행하여 원하는 작업을 수행한다.
- 객체지향 프로그래밍을 지원하며 메모리 관리와 성능에 뛰어난 기능을 제공한다. 표준 라이브러리를 활용하여 다양한 작업을 간편하게 처리할 수 있다.
- 링크 과정을 통해 각 obj 파일의 관계가 서로 연결이 되고 이때, 필요로 하는 라이브러리도 함께 코드화되어 실행 가능한 파일이 만들어진다.
- cpp 파일을 기준으로 컴파일되므로 cpp에 include 된 적이 없는 헤더 파일은 컴파일되지 않는다.(이러한 헤더 파일에는 프로그램 코드가 아닌 아무렇게 적은 텍스트가 있더라도 상관없다.)

![image](https://github.com/YangYubin12/CPP/assets/102217712/cfcedd29-f51c-4176-9628-d18634da1ab7)

## <br> 2. 스레드
- 스레드는 프로세스 내부의 작업의 흐름, 단위.
- C++에서 스레드는 병렬 실행을 가능하게 해주는 독립적인 실행 흐름.
- 기본적으로 프로세스는 최소 1개의 스레드를 가지고 있다.
- <thread> 헤더를 사용하여 스레드 생성과 조작 가능.
- 멀티코어 CPU 활용 및 비동기 작업 처리에 유용한 기능 제공.
- 프로세스는 하나의 프로그램이 실행되고 종료되는 처리라고 이야기하면 한 개의 프로세스 안에는 여러개의 스레드를 설정할 수 있다.

## <br> 3. 네임 맹글링
- C++ 컴파일러가 함수 및 변수 이름을 고유한 형태로 변환하는 과정.
- C++ 컴파일러들이 각 컴파일러마다 자신들만의 규칙으로 함수 이름을 변경하는 것.
- 함수 오버로딩과 네임스페이스 지원을 위해 사용되며, 함수 시그니처와 타입 정보를 포함.
- 링커가 올바른 함수를 연결하기 위해 필요하며, C와 호환되지 않는 형태로 이름을 변경하여 충돌을 방지함.

<img width="813" alt="스크린샷 2023-08-13 오전 4 47 56" src="https://github.com/YangYubin12/CPP/assets/102217712/94f6252e-616d-418b-ad5d-9cae0f9aad6d">

## <br> 4. 페이징
- C++ 메모리 관리에서 페이징은 가상 메모리를 물리적 메모리로 매핑하는 기술.
- 운영체제의 메모리 관리 유닛인 페이지 테이블을 사용하여 가상 주소를 실제 주소에 연결.
- 페이징은 메모리 보호, 공유 및 효율적인 메모리 사용을 지원하며, 프로세스 간 간섭을 제한하는 데 도움을 줌.

## <br> 5. 세그멘테이션
- 세그멘테이션은 메모리 보호 및 가상 주소 공간을 분리하는 메모리 관리 기술.
- 각 세그먼트는 프로그램의 논리적 요소(코드, 데이터, 스택)에 대응하며, 독립적으로 크기와 보호 설정을 갖음.
- 세그멘테이션 오류는 포인터가 유효하지 않은 주소를 참조할 때 발생하며, 이는 프로그램의 안정성을 해치는 원인이 될 수 있음.
### 세그멘테이션 오류
- 운영 체제(OS)에서 세그멘테이션 오류는 프로그램이 올바르지 않은 메모리 영역에 접근하려고 할 때 발생하는 예외. 
- 예외 발생 시 운영 체제는 프로세스를 종료시키고 종종 코어 덤프를 생성한다.
- 주로 C/C++ 코드에서 자주 발생. C/C++에서는 메모리 관리를 개발자가 수동으로 해야 하는 특성을 가지고 있기 때문이다.

### 발생하는 상황들
1. 함수 포인터를 초기화하지 않고 호출
    ```
    void (*func_ptr)(); // 초기화되지 않은 함수 포인터
    func_ptr(); // 초기화되지 않은 함수 포인터 호출로 인한 세그멘테이션 위반 발생
    ```
2. 배열 범위를 넘어서는 인덱스 사용
    ```
    int arr[10];
    arr[100] = 42; // 범위를 벗어난 인덱스 사용
    ```
3. 동적 메모리 할당 후 해제한 메모리에 접근
    ```
    int *ptr = (int *)malloc(sizeof(int));
    free(ptr);
    *ptr = 42; // 이미 해제된 메모리에 접근
    ```
4. 스택 오버플로우. 재귀 함수를 사용할 때 깊이 제한을 설정하지 않거나, 함수 호출 시에 스택 메모리를 과도하게 사용
    ```
    void recursive_function() {
      int large_array[100000];
      recursive_function(); // 스택 오버플로우로 인한 세그멘테이션 위반 발생
    }
    ```
5. 널 포인터 참조. 초기화되지 않은 포인터를 사용하거나, 널(NULL)로 설정된 포인터를 참조
    ```
    int *ptr = NULL;
    *ptr = 42; // 널 포인터 참조로 인한 세그멘테이션 위반 발생
    ```

## <br> 6. 커널 힙 알고리즘
### 커널
- 커널은 컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램이다.
- 컴퓨터의 모든 요소들을 제어할 수 있다.
- 프로세스가 운영체제로부터 시스템 자원을 할당받는다고 했는데, 이처럼 프로세스에게 자원을 할당해주는 것이 커널이다.
- 커널은 한정된 시스템 자원을 효율적으로 관리해주며, 프로세스에게 자원을 할당해주는 역할을 스케줄링이라고 한다.
- 커널은 힙 정렬 알고리즘을 사용한다.
- 이유는 리눅스 커널의 헤더 노트에서 확인할 수 있는데, 힙 정렬은 구조체 배열같은 사용자가 정의한 데이터들도 정렬을 할 수 있기 때문이다.

### 힙
- 트리를 구성해 정렬을 진행하는 알고리즘이다.
- 최소힙과 최대힙 트리, 크게 두 가지로 나뉜다.
  + 최대힙은 트리의 루트가 제일 큰 값으로 정렬되며, 최소힙은 반대로 루트가 제일 작은 값으로 정렬되는 알고리즘이다.
  + 내림차순 정렬을 위해서는 최대 힙을 구성하고, 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
- 인덱스 순으로 새로운 노드를 삽입한 다음, 삽입한 상태에서 형제 노드와 부모 노드와 값을 비교하여 만약 자신이 더 크다면 현재 자신의 위치와 더 작은 노드의 값을 바꾸며 정렬을 하는 알고리즘.

## <br> 7. vertor
- 벡터는 C++의 표준라이브러리에 있는 컨테이너로, 사용자가 사용하기 편하게 정의된 class를 벡터라고 한다.
- 속도적인 측면에서는 배열에 비해서 성능이 떨어진다. 하지만 메모리를 효율적으로 관리할 수 있고 예외처리까지 쉽다는 장점이 있어 많이 사용된다.

### 사용법
<img width="666" alt="스크린샷 2023-08-13 오전 5 16 23" src="https://github.com/YangYubin12/CPP/assets/102217712/eba1dfb3-0bf7-4e94-8b50-840a73e63220">
 
  ```
  vector<int> v;        // int형 백터 생성

  vector<int>v(4);    // int형 백터 생성 후 크기를 4로 할당(모든 백터요소 0으로 초기화)

  vector<int>v = { 1, 2, 3 };        // int형 백터 생성 후 1, 2, 3 으로 초기화

  vector<int>v[] = {{1, 2}, {3, 4}};        // int형 백터 배열 생성(행은 가변이지만 열은 고정)

  vector<vector<int>> v;        // 2차원 백터 생성(행과 열 모두 가변)

  vector<int> v = { 1, 2, 3, 4, 5};        // 백터 범위를 5로 지정하고 정수 10으로 초기화

  v.assign(5, 10);    // 10 10 10 10 10
  ```

<img width="562" alt="스크린샷 2023-08-13 오전 5 18 06" src="https://github.com/YangYubin12/CPP/assets/102217712/978c58f0-77a8-4188-91cc-d8253c96841f">


## <br> 8. 덱
- 덱은 데이터를 앞으로도 뒤로도 입력할 수 있고, 앞으로도 뒤로도 출력이 가능한 큐 혹은 스택 혹은 두 개 모두와 같은 자료형이다.
- 덱은 큐와 스택을 모두 가진 것처럼, 앞으로 삽입 후 뒤로 뺄 수도, 앞으로 뺄 수도 있다.
- 큐 안에 큐를 넣은 것.
  
![image](https://github.com/YangYubin12/CPP/assets/102217712/35e24a7e-5c45-4813-8952-77cf90968446)

<br>

## 출처
* [출처 1: c++ 컴파일 프로세스(과정)](https://blog.naver.com/PostView.naver?blogId=herbbread&logNo=220519164335)
* [출처 2: [C++] 쓰레드(Thread)를 사용하는 방법](https://nowonbun.tistory.com/732) &nbsp;
* [출처 3: [C/C++] EXTERN "C"와 네임 맹글링](https://5kyc1ad.tistory.com/343)
* [출처 4: [C++ 입문자에서 벗어나기]Chapter_4: 메모리(Memory)#1](https://kfgd.tistory.com/18)
* [출처 5: [세그멘테이션(Segmentation) 오류란?]](https://change-words.tistory.com/entry/Segmentation-fault)
* [출처 6: [컴퓨터 과학 도장깨기]](https://velog.io/@ubin_ing/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99%EB%8F%84%EC%9E%A5%EA%B9%A8%EA%B8%B0)
